#ifndef REP_INSTRUMENTCLUSTER_SOURCE_H
#define REP_INSTRUMENTCLUSTER_SOURCE_H

// This is an autogenerated file.
// Do not edit this file, any changes made will be lost the next time it is generated.

#include <QtCore/qobject.h>
#include <QtCore/qdatastream.h>
#include <QtCore/qvariant.h>
#include <QtCore/qmetatype.h>

#include <QtRemoteObjects/qremoteobjectnode.h>
#include <QtRemoteObjects/qremoteobjectsource.h>

#include "instrumentclustermodule.h"

#include "warning.h"

class InstrumentClusterSource : public QObject
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "InstrumentCluster")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "8d8d757af0e2646b02ce349cce7c8d5a9351d577")
    Q_PROPERTY(int speed READ speed NOTIFY speedChanged)
    Q_PROPERTY(int rpm READ rpm NOTIFY rpmChanged)
    Q_PROPERTY(qreal fuel READ fuel NOTIFY fuelChanged)
    Q_PROPERTY(qreal temperature READ temperature NOTIFY temperatureChanged)
    Q_PROPERTY(InstrumentClusterModule::SystemType systemType READ systemType NOTIFY systemTypeChanged)
    Q_PROPERTY(Warning currentWarning READ currentWarning NOTIFY currentWarningChanged)

public:
    explicit InstrumentClusterSource(QObject *parent = nullptr) : QObject(parent)
    {
        qRegisterMetaType<Warning>();
        qRegisterMetaTypeStreamOperators<Warning>();
        qRegisterMetaType<InstrumentClusterModule::SystemType>();
        qRegisterMetaTypeStreamOperators<InstrumentClusterModule::SystemType>();

    }

public:
    virtual ~InstrumentClusterSource() {}

    virtual int speed() const = 0;
    virtual int rpm() const = 0;
    virtual qreal fuel() const = 0;
    virtual qreal temperature() const = 0;
    virtual InstrumentClusterModule::SystemType systemType() const = 0;
    virtual Warning currentWarning() const = 0;

Q_SIGNALS:
    void speedChanged(int speed);
    void rpmChanged(int rpm);
    void fuelChanged(qreal fuel);
    void temperatureChanged(qreal temperature);
    void systemTypeChanged(InstrumentClusterModule::SystemType systemType);
    void currentWarningChanged(Warning currentWarning);
    void pendingResultAvailable(quint64 id, bool isSuccess, const QVariant & value);

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
#endif


class InstrumentClusterSimpleSource : public InstrumentClusterSource
{
    Q_OBJECT

public:
    explicit InstrumentClusterSimpleSource(QObject *parent = nullptr) : InstrumentClusterSource(parent)
    , m_speed()
    , m_rpm()
    , m_fuel()
    , m_temperature()
    , m_systemType()
    , m_currentWarning()
    {
    }

public:
    virtual ~InstrumentClusterSimpleSource() {}

    int speed() const override { return m_speed; }
    int rpm() const override { return m_rpm; }
    qreal fuel() const override { return m_fuel; }
    qreal temperature() const override { return m_temperature; }
    InstrumentClusterModule::SystemType systemType() const override { return m_systemType; }
    Warning currentWarning() const override { return m_currentWarning; }

protected:
    virtual void setSpeed(int speed)
    {
        if (speed != m_speed) {
            m_speed = speed;
            Q_EMIT speedChanged(m_speed);
        }
    }
    virtual void setRpm(int rpm)
    {
        if (rpm != m_rpm) {
            m_rpm = rpm;
            Q_EMIT rpmChanged(m_rpm);
        }
    }
    virtual void setFuel(qreal fuel)
    {
        if (fuel != m_fuel) {
            m_fuel = fuel;
            Q_EMIT fuelChanged(m_fuel);
        }
    }
    virtual void setTemperature(qreal temperature)
    {
        if (temperature != m_temperature) {
            m_temperature = temperature;
            Q_EMIT temperatureChanged(m_temperature);
        }
    }
    virtual void setSystemType(InstrumentClusterModule::SystemType systemType)
    {
        if (systemType != m_systemType) {
            m_systemType = systemType;
            Q_EMIT systemTypeChanged(m_systemType);
        }
    }
    virtual void setCurrentWarning(Warning currentWarning)
    {
        if (currentWarning != m_currentWarning) {
            m_currentWarning = currentWarning;
            Q_EMIT currentWarningChanged(m_currentWarning);
        }
    }

private:
    int m_speed;
    int m_rpm;
    qreal m_fuel;
    qreal m_temperature;
    InstrumentClusterModule::SystemType m_systemType;
    Warning m_currentWarning;
};


template <class ObjectType>
struct InstrumentClusterSourceAPI : public SourceApiMap
{
    InstrumentClusterSourceAPI(ObjectType *object, const QString &name = QStringLiteral("InstrumentCluster"))
        : SourceApiMap(), m_name(name)
    {
        Q_UNUSED(object);
        m_enums[0] = 0;
        m_properties[0] = 6;
        m_properties[1] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::speed, static_cast<int (QObject::*)()>(0),"speed");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::speedChanged, static_cast<void (QObject::*)()>(0));
        m_properties[2] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::rpm, static_cast<int (QObject::*)()>(0),"rpm");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::rpmChanged, static_cast<void (QObject::*)()>(0));
        m_properties[3] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::fuel, static_cast<qreal (QObject::*)()>(0),"fuel");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::fuelChanged, static_cast<void (QObject::*)()>(0));
        m_properties[4] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::temperature, static_cast<qreal (QObject::*)()>(0),"temperature");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::temperatureChanged, static_cast<void (QObject::*)()>(0));
        m_properties[5] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::systemType, static_cast<InstrumentClusterModule::SystemType (QObject::*)()>(0),"systemType");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::systemTypeChanged, static_cast<void (QObject::*)()>(0));
        m_properties[6] = QtPrivate::qtro_property_index<ObjectType>(&ObjectType::currentWarning, static_cast<Warning (QObject::*)()>(0),"currentWarning");
        QtPrivate::qtro_method_test<ObjectType>(&ObjectType::currentWarningChanged, static_cast<void (QObject::*)()>(0));
        m_signals[0] = 7;
        m_signals[1] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::speedChanged, static_cast<void (QObject::*)(int)>(0),m_signalArgCount+0,&m_signalArgTypes[0]);
        m_signals[2] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::rpmChanged, static_cast<void (QObject::*)(int)>(0),m_signalArgCount+1,&m_signalArgTypes[1]);
        m_signals[3] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::fuelChanged, static_cast<void (QObject::*)(qreal)>(0),m_signalArgCount+2,&m_signalArgTypes[2]);
        m_signals[4] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::temperatureChanged, static_cast<void (QObject::*)(qreal)>(0),m_signalArgCount+3,&m_signalArgTypes[3]);
        m_signals[5] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::systemTypeChanged, static_cast<void (QObject::*)(InstrumentClusterModule::SystemType)>(0),m_signalArgCount+4,&m_signalArgTypes[4]);
        m_signals[6] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::currentWarningChanged, static_cast<void (QObject::*)(Warning)>(0),m_signalArgCount+5,&m_signalArgTypes[5]);
        m_signals[7] = QtPrivate::qtro_signal_index<ObjectType>(&ObjectType::pendingResultAvailable, static_cast<void (QObject::*)(quint64,bool,QVariant)>(0),m_signalArgCount+6,&m_signalArgTypes[6]);
        m_methods[0] = 0;
    }

    QString name() const override { return m_name; }
    QString typeName() const override { return QStringLiteral("InstrumentCluster"); }
    int enumCount() const override { return m_enums[0]; }
    int propertyCount() const override { return m_properties[0]; }
    int signalCount() const override { return m_signals[0]; }
    int methodCount() const override { return m_methods[0]; }
    int sourceEnumIndex(int index) const override
    {
        if (index < 0 || index >= m_enums[0])
            return -1;
        return m_enums[index+1];
    }
    int sourcePropertyIndex(int index) const override
    {
        if (index < 0 || index >= m_properties[0])
            return -1;
        return m_properties[index+1];
    }
    int sourceSignalIndex(int index) const override
    {
        if (index < 0 || index >= m_signals[0])
            return -1;
        return m_signals[index+1];
    }
    int sourceMethodIndex(int index) const override
    {
        if (index < 0 || index >= m_methods[0])
            return -1;
        return m_methods[index+1];
    }
    int signalParameterCount(int index) const override
    {
        if (index < 0 || index >= m_signals[0])
            return -1;
        return m_signalArgCount[index];
    }
    int signalParameterType(int sigIndex, int paramIndex) const override
    {
        if (sigIndex < 0 || sigIndex >= m_signals[0] || paramIndex < 0 || paramIndex >= m_signalArgCount[sigIndex])
            return -1;
        return m_signalArgTypes[sigIndex][paramIndex];
    }
    int methodParameterCount(int index) const override { Q_UNUSED(index); return -1; }
    int methodParameterType(int methodIndex, int paramIndex) const override
    { Q_UNUSED(methodIndex); Q_UNUSED(paramIndex); return -1; }
    int propertyIndexFromSignal(int index) const override
    {
        switch (index) {
        case 0: return m_properties[1];
        case 1: return m_properties[2];
        case 2: return m_properties[3];
        case 3: return m_properties[4];
        case 4: return m_properties[5];
        case 5: return m_properties[6];
        }
        return -1;
    }
    int propertyRawIndexFromSignal(int index) const override
    {
        switch (index) {
        case 0: return 0;
        case 1: return 1;
        case 2: return 2;
        case 3: return 3;
        case 4: return 4;
        case 5: return 5;
        }
        return -1;
    }
    const QByteArray signalSignature(int index) const override
    {
        switch (index) {
        case 0: return QByteArrayLiteral("speedChanged(int)");
        case 1: return QByteArrayLiteral("rpmChanged(int)");
        case 2: return QByteArrayLiteral("fuelChanged(qreal)");
        case 3: return QByteArrayLiteral("temperatureChanged(qreal)");
        case 4: return QByteArrayLiteral("systemTypeChanged(InstrumentClusterModule::SystemType)");
        case 5: return QByteArrayLiteral("currentWarningChanged(Warning)");
        case 6: return QByteArrayLiteral("pendingResultAvailable(quint64,bool,QVariant)");
        }
        return QByteArrayLiteral("");
    }
    QList<QByteArray> signalParameterNames(int index) const override
    {
        if (index < 0 || index >= m_signals[0])
            return QList<QByteArray>();
        return ObjectType::staticMetaObject.method(m_signals[index + 1]).parameterNames();
    }
    const QByteArray methodSignature(int index) const override
    {
        Q_UNUSED(index);
        return QByteArrayLiteral("");
    }
    QMetaMethod::MethodType methodType(int) const override
    {
        return QMetaMethod::Slot;
    }
    QList<QByteArray> methodParameterNames(int index) const override
    {
        if (index < 0 || index >= m_methods[0])
            return QList<QByteArray>();
        return ObjectType::staticMetaObject.method(m_methods[index + 1]).parameterNames();
    }
    const QByteArray typeName(int index) const override
    {
        Q_UNUSED(index);
        return QByteArrayLiteral("");
    }
    QByteArray objectSignature() const override { return QByteArray{"8d8d757af0e2646b02ce349cce7c8d5a9351d577"}; }

    int m_enums[1];
    int m_properties[7];
    int m_signals[8];
    int m_methods[1];
    const QString m_name;
    int m_signalArgCount[7];
    const int* m_signalArgTypes[7];
};

QT_BEGIN_NAMESPACE
QT_END_NAMESPACE


#endif // REP_INSTRUMENTCLUSTER_SOURCE_H
